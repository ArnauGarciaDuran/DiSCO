import numpy as npimport matplotlib.pyplot as pltfrom scipy.optimize import rootimport os######################### ***INPUT*** ############################ ***MANUAL MODE*** ### Uncomment to activate Manual Mode# Defining parameters#R = 8.31	#J/Kmol (ideal gas constant)#Tini = 0	#Initial temperature to analize#Tfin = 800	#Last temperature to analize#dT = 0.01	#Increment of temperatures# Defining thermodinamic data#Systems_name = ["empty"]#dH2_values = np.array([37045.7312])	#J/mol  (dH(QQ-QS))#dS2_values = np.array([68.15310107])	#J/Kmol (dS(QQ-QS))#dH1_values = np.array([37392.29651])	#J/mol  (dH(QS-SS))#dS1_values = np.array([80.01891203])	#J/Kmol (dS(QS-SS))### ***AUTOMATIC MODE*** ### Comment to deactivate Automatic Mode# Defining parametersR, Tini, Tfin, dT = np.loadtxt('parameters.dat', skiprows=1).T# Defining thermodinamic data - Autom√†tic ModeSystems_name, dH2_values, dS2_values, dH1_values, dS1_values =  np.loadtxt('input.dat', skiprows=1, dtype='str').TdH2_values = dH2_values.astype(float); dS2_values = dS2_values.astype(float); dH1_values = dH1_values.astype(float); dS1_values = dS1_values.astype(float) ######################################################################################## ***FUNCTIONS*** #########################def equations(xy):    """    Defining the equations which we need to find the roots.    Eq1 = dG(x, y)/dx    Eq2 = dG(x, y)/dy    Parameters:    ---------------    xy : Array that contains x(molar fraction of SS) and y(molar fraction of QS)    Return:    ---------------    [eq1,eq2] : Array that contains the result of (dG(x,y)/dx, dG(x,y)/dy)    """    x, y = xy    dH = dH1 + dH2    dS = dS1 + dS2    eq1 = R * T * np.log(x) - R * T * np.log(1-x-y) + dS * T - dH    eq2 = R * T * np.log(y) - R * T * np.log(1-x-y) + dS/2 * T - dH2    return [eq1,eq2]def jac(xy):    """    Defining the jacobian matrix of the equations we want to find the roots (eq1, eq2).    | dG(x,y)2/dxdx   dG(x,y)2/dxdy |    | dG(x,y)2/dydx   dG(x,y)2/dydy |    It is used in the function "scipy.optimize.root" just to have better efficiency.        Parameters:    ---------------    xy : Array that contains x(molar fraction of SS) and y(molar fraction of QS)        Returns:    ---------------    Jacobian matrix defined as in the description    """    x, y = xy    deq1_dx = R*T/x + R*T/(1-x-y)    deq1_dy = R*T/(1-x-y)    deq2_dx = R*T/(1-x-y)    deq2_dy = R*T/y + R*T/(1-y-x)    return [[deq1_dx, deq1_dy], [deq2_dx, deq2_dy]]def c(y,z):    """    Defining a parameter c, which indicates the molar fraction of metal ions in high spin state.        Parameters:    ---------------    y : molar fraction of QS compound    z : molar fraction of QQ compound    Returns:    ---------------    c : value of the c parameter    """    return (y + 2*z)/2########################################################################################### ***COMPUTING VALUES*** #########################temperatures = np.arange(Tini, Tfin, dT)			# Temperatures from Tini to Tfin with an increment of dTx_values = np.empty((len(dH1_values), len(temperatures)))   	# Molar fraction of SSy_values = np.empty((len(dH1_values), len(temperatures)))   	# Molar fraction of QSz_values = np.empty((len(dH1_values), len(temperatures)))   	# Molar fraction of QQfor idx, (dH2, dS2, dH1, dS1) in enumerate(zip(dH2_values, dS2_values, dH1_values, dS1_values)): #Calculate for each system    initial_guess = [0.999999999, 0.0000000005]  # Initial guess [x,y]. Since starts at low temperatures, it has been assumed that x (molar fraction of SS) will be almost 1. If it is not computing correctly, modify the initial guess (p.e. to to [0.99999, 0.000005]).    for j, T in enumerate(temperatures):        #For each temperature find the x and y values that are the root of equacions dG(x,y)/dx and dG(x,y)/dy. Take the computed result as the initial guess for the next temperature.        results = root(equations, initial_guess, jac=jac, method="lm")        x_val, y_val = results.x        initial_guess = [x_val,y_val]        x_values[idx, j] = x_val        y_values[idx, j] = y_val        z_values[idx, j] = 1 - x_val - y_val # Also computes z value as 1-x-y (sum of molar fractions must be 1)################################################################################################### ***PLOTS*** ########################## Do the plots of each system, save it as systems_name.png and print the transition temperatures of each systemfor system, (dH2, dS2, dH1, dS1) in enumerate(zip(dH2_values, dS2_values, dH1_values, dS1_values)):    fig, axs = plt.subplots(1, 3, figsize=(20, 5))    # First plot: c parameter (molar fraction of Fe ions in high-spin state) vs temperature    axs[0].plot(temperatures, c(y_values[system,:],z_values[system,:]))    axs[0].set_xlabel("Temperatures (K)", size=14); axs[0].set_ylabel("c", size=14)    axs[0].set_ylim(0,1); axs[0].set_xlim(Tini,Tfin)    critical_temperature = int((dH1+dH2) / (dS1+dS2)) #Compute critical temperature as dH/dS    axs[0].axvline(x=critical_temperature, color='red', linestyle='--')    axs[0].text(critical_temperature + 1.0, 0.9, f'T$_1$$_/$$_2$ is {critical_temperature}', color='red')    # Second plot: molar fractions vs temperature    axs[1].plot(temperatures, x_values[system,:], label="[SS]")    axs[1].plot(temperatures, y_values[system,:], label="[SQ]")    axs[1].plot(temperatures, z_values[system,:], label="[QQ]")    axs[1].set_xlabel("Temperatures (K)", size=14); axs[1].set_ylabel("Molar fractions", size=14)    axs[1].set_ylim(0,1); axs[1].set_xlim(Tini,Tfin)    axs[1].legend()    axs[1].set_title(Systems_name[system], size=18)        # Compute critical temperatures of each step as [SS] = [QS] for the first step and [QS] = [QQ] for the second step    def x_interp(T): # Interpolate the molar fractions in function of T        x_interp_func = np.interp(T, temperatures[:], x_values[system,:])        return x_interp_func    def y_interp(T): # Interpolate the molar fractions in function of T        y_interp_func = np.interp(T, temperatures[:], y_values[system,:])        return y_interp_func    def z_interp(T): # Interpolate the molar fractions in function of T        z_interp_func = np.interp(T, temperatures[:], z_values[system,:])        return z_interp_func    critical_temperature1 = root(lambda T: x_interp(T)-y_interp(T), critical_temperature-5, method="lm").x[0]    critical_temperature2 = root(lambda T: y_interp(T)-z_interp(T), critical_temperature+5, method="lm").x[0]        if critical_temperature1 < critical_temperature2:            axs[1].axvline(x=critical_temperature1, color='red', linestyle='--', lw=1.0)        axs[1].text(critical_temperature1 + 1.0, 0.9, f'T$_1$$_/$$_2$1 is {int(critical_temperature1)}', color='red')        axs[1].axvline(x=critical_temperature2, color='red', linestyle='--', lw=1.0)        axs[1].text(critical_temperature2 + 1.0, 0.8, f'T$_1$$_/$$_2$2 is {int(critical_temperature2)}', color='red')    else:         axs[1].axvline(x=critical_temperature, color='red', linestyle='--', lw=1.0)        axs[1].text(critical_temperature + 1.0, 0.9, f'T$_1$$_/$$_2$1 is {int(critical_temperature)}', color='red')            # Calculate the enthalpy values for each temperature since we have found the x,y and z values at each temperature    H_values = y_values[system,:]*(dH1) + z_values[system,:]*(dH1+dH2)    # Calculate the heat capacity as dH(T)/dT for each temperature    Cp_values = np.zeros(len(temperatures) - 1)    for i in range(len(temperatures)-1):        Cp_values[i] = (H_values[i+1]-H_values[i])/dT    # Third plot: heat capacity vs temperature    axs[2].plot(temperatures[:-1], Cp_values)    axs[2].set_xlabel("Temperatures (K)", size=14); axs[2].set_ylabel("Cp (J/molK)", size=14)    axs[2].set_ylim(); axs[2].set_xlim(Tini,Tfin)    # Save the plots as "system_name.png" in a directory name "output"    if not os.path.exists("output"):        os.makedirs("output")    plt.savefig("output/" + Systems_name[system] + ".png", dpi=1000)    plt.close()    # Write in a file temperatures, molar fraction and c_parameter so it can be used to obtain a more fancier plot:    with open("output/" + Systems_name[system] + ".txt", "w") as output:        output.write(f"#x (molar fraction SS)\t #y (molar fraction QS)\t #z (molar fraction QQ)\t #c (molar fraction ions HS)\t #T (temperatures [K])\n")        for ii in range(len(temperatures)):                output.write(f"{x_values[system,ii]}\t{y_values[system,ii]}\t{z_values[system,ii]}\t{c(y_values[system,ii],z_values[system,ii])}\t{round(temperatures[ii], 1)}\n")    # Print in the terminal the critical temperatures    print(r"*** {} ***".format(Systems_name[system]))    print("------------------")    print(u'T\u00BD = {}'.format(int(critical_temperature)))    if critical_temperature1 < critical_temperature2:         print(u'T\u00BD (SS-QS) = {}'.format(int(critical_temperature1)))        print(u'T\u00BD (QS-QQ) = {}'.format(int(critical_temperature2)))        # Compute the first and second derivative of c_values. If in the first derivative there is just one maximum it a one-step transition. If there is two, two-step transition.    c_values = c(y_values[system,:],z_values[system,:])    dc_values = np.zeros(len(temperatures) - 2)    i=1    while i < len(temperatures)-1:         dc_values[i-1] = (c_values[i+1]-c_values[i-1])/(2*dT)        i=i+1        d2c_values = np.zeros(len(temperatures) - 4)    i=2    while i < len(temperatures)-2:         d2c_values[i-2] = (dc_values[i]-dc_values[i-2])/(2*dT)        i=i+1        if critical_temperature1 < critical_temperature2:         if (d2c_values[np.where(temperatures == round(critical_temperature1))[0]] > 0 and d2c_values[np.where(temperatures == round(critical_temperature2))[0]]) > 0 or (d2c_values[np.where(temperatures == round(critical_temperature1))[0]] < 0 and d2c_values[np.where(temperatures == round(critical_temperature2))[0]] < 0):            print("2-Step transition")        else:            print("1-Step transition") # It may fail finding two minimum very close to each other and deciding is a two-step when in it not. Be careful!    print("")###############################################################